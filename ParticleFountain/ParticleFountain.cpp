/*
 * Geneva Smith
 * File: ParticleFountain.cpp
 * ---------------------------------------------------------
 * This file draws a particle fountain that can be affected
 * by physics.
 */

#include <iostream>
#include <conio.h>
#include <stdlib.h>
#include <stdio.h>
#include <gl/glut.h>
#include <gl/gl.h>
#include <list>
#include <time.h>

#include "particle_class.h"
using namespace std;

/*	ENUMS	*/
enum Channel {R, G, B};
enum Shape {Sphere, Cube, Cone, Torus};

/*	FUNCTION PROTOTYPES	*/
void Reset();
void HelpText();
void Randomize();
void generateParticle();
void DrawParticle(Particle particle);

void DrawFountain();
void Keyboard(unsigned char key, int x, int y);
void ArrowKeys(int key, int x, int y);

void ShapeSubMenu(GLint newShape);
void ColourSubMenu(GLint newColour);
void MainMenu(int dummy);

/*	GLOBAL VARIABLES	*/
const int minX = -100;
const int maxX = 100;
const int minY = -100;
const int maxY = 100;
const int minZ = -300;

list<Particle> particleList;
list<Particle>::iterator p;
int startSize = 3;
int maxAge = 3000;
int step = 1;
int particleCounter = 0;
int timer = 10;

bool frictionMode = false;
bool pause = false;

bool lighting = false;
bool controlLight1 = true;
GLfloat light0pos [] = {50, 100, 0, 1};
GLfloat light1pos [] = {-50, 100, 0, 1};
const int lightStep = 5;

double c[3] = {1, 1, 1};
bool randomflag = true;

Shape drawShape = Cube;
int slices = 8;
int stacks = 8;

/*	FUNCTION DEFINITIONS	*/

/*
 * Function: Randomize
 * --------------------------------------------------------------------------------
 * Sets a starting point for particle generation.
 */
void Randomize()
{
	srand(time(NULL));
	return;
}

/*
 * Function: Reset
 * --------------------------------------------------------------------------------
 * Resets the program to a new fountain. Clears all currently active particles.
 */
void Reset()
{
	particleList.clear();
	startSize = 3;
	frictionMode = false;
	pause = false;

	return;
}

/*
 * Function: HelpText
 * -------------------------------------------------------------------------------
 * Displays instructions and gets screen resolution from user.
 */
void HelpText()
{
	cout<<"Instructions:"; cout<<endl;
	cout<<"----------------------------------------------------------------"; cout<<endl;
	cout<<"Spacebar: Pause and unpause particle generation"; cout<<endl;
	cout<<"-----"; cout<<endl;
	cout<<"F/f: Turn friction on or off - friction affects how fast the particles move"; cout<<endl;
	cout<<"-----"; cout<<endl;
	cout<<"L/l: Toggles lighting on and off"; cout<<endl;
	cout<<"I/i: Switch between light sources"; cout<<endl;
	cout<<"G/g and H/h: Move the light along the x axis"; cout<<endl;
	cout<<"T/t and B/b: Move the light along the y axis"; cout<<endl;
	cout<<"V/v and Y/y: Move the light along the z axis"; cout<<endl;
	cout<<"-----"; cout<<endl;
	cout<<"Right click brings up colour and shape options for particles"; cout<<endl;
	cout<<"-----"; cout<<endl;
	cout<<"Q/q: Exit the particle fountain"; cout<<endl;
	cout<<endl;
	cout<<"Press enter to continue..."; cout<<endl;
	_getch();

	return;
}

/*
 * Function: generateParticle
 * ---------------------------------------------------------------------
 * Tracks how long until the next particle is added and adds it to the 
 * particle list.
 */
void generateParticle()
{
	if(pause == false)
	{
		particleCounter++;
	
		if(particleCounter % timer == 0)
		{
			Particle newParticle(startSize);

			// Change colour if needed
			if(!randomflag) newParticle.SetColour(c[R], c[G], c[B]);

			particleList.push_back(newParticle);
			particleCounter = 0;
		}
	}

	return;
}

/* 
 * Function: DrawParticle
 * ----------------------------------------------------------------------
 * Draws a particle using OpenGL
 */
void DrawParticle(Particle particle)
{
	glPushMatrix();

	glTranslatef(particle.GetXLocation(), particle.GetYLocation(), particle.GetZLocation());

	glRotatef(particle.GetXSpin(), 1, 0, 0);
	glRotatef(particle.GetYSpin(), 0, 1, 0);
	glRotatef(particle.GetZSpin(), 0, 0, 1);

	glColor3f(particle.GetRed(), particle.GetGreen(), particle.GetBlue());

	// Draw particle shape
	if(drawShape == Sphere) glutSolidSphere(particle.GetSize(), slices, stacks);
	else if(drawShape == Cube) glutSolidCube(particle.GetSize());
	else if(drawShape == Cone) glutSolidCone(particle.GetSize(), 2*particle.GetSize(), slices, stacks);
	else if(drawShape == Torus) glutSolidTorus(particle.GetSize()/2, particle.GetSize(), slices, stacks);

	glPopMatrix();

	return;
}

/* 
 * Function: DrawFountain
 * ----------------------------------------------------------------------
 * Draws OpenGL elements
 */

void DrawFountain() //draws the particles generated by the fountain
{
	// Add new particle every 8 frames if not paused
	generateParticle();

	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	// Determine if lighting is needed
	if (lighting)
	{
		glEnable(GL_LIGHTING);
		glEnable(GL_COLOR_MATERIAL);

		glLightfv(GL_LIGHT0, GL_POSITION, light0pos);
		glEnable(GL_LIGHT0);

		glLightfv(GL_LIGHT1, GL_POSITION, light1pos);
		glEnable(GL_LIGHT1);
	}
	else glDisable(GL_LIGHTING);

	glShadeModel(GL_SMOOTH);
	// Draw a white surface plane
	// Since it is a flat plane, assign basic normal values for lighting
	glBegin(GL_QUADS);
	glColor3f(1,1,1);

	glNormal3d(0, 1, 0);
	glVertex3f(maxX,minY,0);

	glNormal3d(0, 1, 0);
	glVertex3f(maxX,maxY,0);

	glNormal3d(0, 1, 0);
	glVertex3f(minX,maxY,0);

	glNormal3d(0, 1, 0);
	glVertex3f(minX,minY,0);
	glEnd();

	// Particle calculations
	if(!particleList.empty())
	{
		p = particleList.begin();

		while(p != particleList.end())
		{
			// Draw particle
			DrawParticle(*p);

			// Calculate next particle step
			(*p).IncrementAge(step);
			(*p).ParticleStep();

			// Check if the particle is within the bounds of the plane
			if((*p).GetXLocation() >= minX && (*p).GetXLocation() <= maxX)
			{
				if((*p).GetYLocation() >= minY && (*p).GetYLocation() <= maxY)
				{
					// Calculate if the particle is bouncing and affected by friction
					if((*p).GetZLocation() < 0)
					{
						(*p).Bounce();

						if(frictionMode) (*p).Friction(0.7);
					}
				}
			}
			
			// Erase particles and move iterator to the next particle
			if((*p).GetAge() > maxAge || (*p).GetZLocation() < minZ) p = particleList.erase(p);
			else p++;
		}
	}

	// Prepare for next animation frame
	glutSwapBuffers();
	glutPostRedisplay();
	glFlush();
}

/*
 * Function: Keyboard
 * ------------------------------------
 * Gets input from standard keys
 */
void Keyboard(unsigned char key, int x, int y)
{
	switch (key)
	{
		// Quit program
		case 'Q':
		case 'q': 
		{
			exit(0);
			break;
		}

		// Reset fountain
		case 'R':
		case 'r': 
		{
			Reset();
			break;
		}

		// Pause and unpause
		case ' ':
		{
			pause = !pause;
			break;
		}

		// Control friction
		case 'F':
		case 'f':
		{
			frictionMode = !frictionMode;
			break;
		}

		// Control lighting
		case 'L':
		case 'l':
		{
			lighting = !lighting;
			break;
		}

		case 'I':
		case 'i':
		{
			controlLight1 = !controlLight1;
			break;
		}

		// Move light
		case 'T':
		case 't':
		{
			// Move light up (yaxis)
			if(controlLight1) light0pos[1] += lightStep;
			else light1pos[1] += lightStep;

			break;
		}
		case 'B':
		case 'b':
		{
			// Move light down (yaxis)
			if(controlLight1) light0pos[1] -= lightStep;
			else light1pos[1] -= lightStep;

			break;
		}
		case 'G':
		case 'g':
		{
			// Move light left (xaxis)
			if(controlLight1) light0pos[0] += lightStep;
			else light1pos[0] += lightStep;

			break;
		}
		case 'H':
		case 'h':
		{
			// Move light right (xaxis)
			if(controlLight1) light0pos[0] -= lightStep;
			else light1pos[0] -= lightStep;

			break;
		}
		case 'V':
		case 'v':
		{
			// Move light closer (zaxis)
			if(controlLight1) light0pos[2] += lightStep;
			else light1pos[2] += lightStep;

			break;
		}
		case 'Y':
		case 'y':
		{
			// Move light farther (zaxis)
			if(controlLight1) light0pos[2] -= lightStep;
			else light1pos[2] -= lightStep;

			break;
		}
	}
}

/*
 * Function: ArrowKeys
 * ------------------------------------
 * Gets input from the arrow keys (denoted as 'special keys')
 */
void ArrowKeys(int key, int x, int y) //watches for the up and down key being pressed
{
	switch (key)
	{
		case GLUT_KEY_LEFT:
		{
			glRotatef(-1,0,0,1);
			glutPostRedisplay();
			break;
		}

		case GLUT_KEY_RIGHT:
		{
			glRotatef(1,0,0,1);
			glutPostRedisplay();
			break;
		}

		case GLUT_KEY_UP:
		{
			glRotatef(-1,1,0,0);
			glutPostRedisplay();
			break;
		}

		case GLUT_KEY_DOWN:
		{
			glRotatef(1,1,0,0);
			glutPostRedisplay();
			break;
		}
	}
}

/*
 * Menus
 * ---------------------------------------------------------------
 * Menu functions to enable the changing of particle shape and 
 * colour at runtime.
 */
void MainMenu(int dummy) { return; }

void ShapeSubMenu(GLint newShape)
{
	glutChangeToMenuEntry(1, "Sphere", 1);
	glutChangeToMenuEntry(2, "Cube", 2);
	glutChangeToMenuEntry(3, "Cone", 3);
	glutChangeToMenuEntry(4, "Torus", 4);

	switch(newShape)
	{
		case 1:
			glutChangeToMenuEntry(1, "> Sphere", 1);
			drawShape = Sphere;
			break;
		case 2:
			glutChangeToMenuEntry(2, "> Cube", 2);
			drawShape = Cube;
			break;
		case 3:
			glutChangeToMenuEntry(3, "> Cone", 3);
			drawShape = Cone;
			break;
		case 4:
			glutChangeToMenuEntry(4, "> Torus", 4);
			drawShape = Torus;
			break;
	}

	return;
}

void ColourSubMenu(GLint colour)
{
	glutChangeToMenuEntry(1, "Red", 1);
	glutChangeToMenuEntry(2, "Green", 2);
	glutChangeToMenuEntry(3, "Blue", 3);
	glutChangeToMenuEntry(4, "Yellow", 4);
	glutChangeToMenuEntry(5, "Cyan", 5);
	glutChangeToMenuEntry(6, "Magenta", 6);
	glutChangeToMenuEntry(7, "White", 7);
	glutChangeToMenuEntry(8, "Random", 8);
	

	randomflag = false;

	switch(colour)
	{
		case 1: 
			glutChangeToMenuEntry(1, "> Red", 1);
			c[R] = 1.0; c[G] = 0; c[B] = 0;
			break;
		case 2: 
			glutChangeToMenuEntry(2, "> Green", 2);
			c[R] = 0; c[G] = 1.0; c[B] = 0;
			break;
		case 3: 
			glutChangeToMenuEntry(3, "> Blue", 3);
			c[R] = 0; c[G] = 0; c[B] = 1.0;
			break;
		case 4: 
			glutChangeToMenuEntry(4, "> Yellow", 4);
			c[R] = 1.0; c[G] = 1.0; c[B] = 0;
			break;
		case 5: 
			glutChangeToMenuEntry(5, "> Cyan", 5);
			c[R] = 0; c[G] = 1.0; c[B] = 1.0;
			break;
		case 6: 
			glutChangeToMenuEntry(6, "> Magenta", 6);
			c[R] = 1.0; c[G] = 0; c[B] = 1.0;
			break;
		case 7: 
			glutChangeToMenuEntry(7, "> White", 7);
			c[G] = 1.0; c[G] = 1.0; c[B] = 1.0;
			break;
		case 8: 
			glutChangeToMenuEntry(8, "> Random", 8);
			randomflag = true;
			break;
	}

	return;
}

/*	MAIN	*/
int main(int argc, char** argv)
{
	GLint submenuShape;
	GLint submenuColour;

	// Initialize program and display instructions
	Randomize();
	HelpText();
	glutInit(&argc, argv);

	// Initialize window size and position
	glutInitWindowSize(1000,1000);
	glutInitWindowPosition(0, 0);
	glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
	glutCreateWindow("Particle Fountain");

	// Enable depth testing for lighting
	glEnable(GL_DEPTH_TEST);

	// Cull back faces to save render time
	glEnable(GL_CULL_FACE);
	glCullFace(GL_BACK);

	// Initialize OpenGL camera
	glMatrixMode (GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(45, 1, 1, 10000);
	glMatrixMode (GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(350, 350, 400,0,0,0,0,0,1);

	//Black Background
	glClearColor(0, 0, 0, 0);

	/*	Menus	*/
	// Shape submenu
	submenuShape = glutCreateMenu(ShapeSubMenu);
		glutAddMenuEntry ("Sphere", 1);
		glutAddMenuEntry ("> Cube", 2);
		glutAddMenuEntry ("Cone", 3);
		glutAddMenuEntry ("Torus", 4);
	// Colour submenu
	submenuColour = glutCreateMenu(ColourSubMenu);
		glutAddMenuEntry ("Red", 1);
		glutAddMenuEntry ("Green", 2);
		glutAddMenuEntry ("Blue", 3);
		glutAddMenuEntry ("Yellow", 4);
		glutAddMenuEntry ("Cyan", 5);
		glutAddMenuEntry ("Magenta", 6);
		glutAddMenuEntry ("White", 7);
		glutAddMenuEntry ("> Random", 8);

	//Main Menu
	glutCreateMenu(MainMenu);
		glutAddSubMenu("Shape", submenuShape);
		glutAddSubMenu("Colour", submenuColour);

	//Attach menu to the right mouse button
	glutAttachMenu(GLUT_RIGHT_BUTTON);

	// Initialize input functions
	glutDisplayFunc(DrawFountain);
	glutKeyboardFunc(Keyboard);
	glutSpecialFunc(ArrowKeys);

	// Start program
	glutMainLoop();

	return(0);
}